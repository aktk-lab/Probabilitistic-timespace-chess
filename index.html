<!doctype html>

<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Probabilistic-Timespace-Chess – A/B面スケルトン</title>
  <style>
    :root { --bg:#0b0d10; --card:#131720; --text:#e7edf5; --muted:#9fb2c9; --accent:#6aa3ff; }
    html,body{height:100%;}
    body { margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "ヒラギノ角ゴ ProN", "Hiragino Kaku Gothic ProN", "Noto Sans JP", "メイリオ", Meiryo, sans-serif; }
    .container{max-width:1100px; margin:40px auto; padding:0 16px;}
    .grid{display:grid; grid-template-columns: 1fr 1fr; gap:16px;}
    .card{background:var(--card); border:1px solid #1f2633; border-radius:16px; padding:16px; box-shadow:0 6px 24px rgba(0,0,0,.25)}
    .title{font-size:20px; font-weight:700; letter-spacing:.02em;}
    .muted{color:var(--muted); font-size:12px}
    .fen{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#0f141c; border:1px solid #202a3a; border-radius:10px; padding:10px; overflow:auto;}
    .row{display:flex; gap:8px; align-items:center;}
    .row + .row{margin-top:8px}
    input, select { background:#0f141c; border:1px solid #283248; color:var(--text); padding:10px 12px; border-radius:10px; outline:none;}
    input:focus{border-color:var(--accent)}
    button{ background:var(--accent); color:#08111f; border:none; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer;}
    button.secondary{ background:#232b3a; color:var(--text); }
    .footer{margin-top:14px; display:flex; gap:8px; align-items:center; justify-content:space-between}
    .hint{font-size:12px; color:var(--muted)}
    @media (max-width: 900px){ .grid{grid-template-columns:1fr} }
    .board{ display:grid; grid-template-columns: repeat(8, 1fr); gap:2px; margin-top:8px; }
    .sq{ aspect-ratio: 1/1; display:flex; align-items:center; justify-content:center; border-radius:6px; }
    .sq.light{ background:#d8dee9; color:#2e3440 }
    .sq.dark{ background:#4c566a }
  </style>
  <!-- 公式のチェスルール実装（SAN→FEN 用） -->
  <script src="https://cdn.jsdelivr.net/npm/chess.js@1.0.0/dist/chess.min.js"></script>
</head>
<body>
  <div class="container">
    <h1 style="margin:0 0 18px 0">Probabilistic‑Timespace‑Chess <span class="muted">（A面=実体／B面=確率投影）</span></h1><div class="card" style="margin-bottom:16px">
  <div class="row" style="flex-wrap:wrap">
    <label>初期FEN: <input id="initFen" value="startpos" style="min-width:260px" /></label>
    <label>バリアント:
      <select id="variant">
        <option value="probProjection">probProjection（確率投影・B面を導出）</option>
        <option value="standard">standard（通常チェス・B面=実体）</option>
      </select>
    </label>
    <label>Seed: <input id="seed" type="number" value="123456789" style="width:160px" /></label>
    <button id="btnStart">ゲーム開始</button>
    <button id="btnReset" class="secondary">リセット</button>
  </div>
  <div class="row" style="margin-top:10px">
    <label>着手（SAN想定）: <input id="moveSan" placeholder="e4, Nf3 など" /></label>
    <button id="btnMove">指す</button>
    <span class="hint">※ chessエンジン連携がない場合は下の簡易盤／FENで動作確認だけできます</span>
  </div>
</div>

<div class="grid">
  <div class="card">
    <div class="title">A面（実体）</div>
    <div class="muted">trueState.fen を表示（本番では盤面レンダラに渡す）</div>
    <pre id="fenA" class="fen">startpos</pre>
    <div id="boardA" class="board" aria-label="A board"></div>
  </div>
  <div class="card">
    <div class="title">B面（確率投影）</div>
    <div class="muted">bState.fen を表示（投影ロジックで導出）</div>
    <pre id="fenB" class="fen">startpos</pre>
    <div id="boardB" class="board" aria-label="B board"></div>
  </div>
</div>

<div class="footer">
  <div class="hint">実装方針：A面=唯一の真実／B面=毎手後に projectToB(trueState, rules, seed) で再計算</div>
  <div class="muted">v0.1 demo</div>
</div>

  </div>  <script type="module">
    // ====== 型っぽい定義（JSDocで補助）
    /** @typedef {{ fen: string, version: number, ply: number }} TrueState */
    /** @typedef {{ fen: string }} BState */
    /** @typedef {{ variant: 'probProjection'|'standard' }} Rules */
    /** @typedef {{ trueState: TrueState, bState: BState, rules: Rules, seed: number }} GameState */

    // ====== 乱数（決定論シード）
    function mulberry32(a){
      return function(){
        let t = (a += 0x6D2B79F5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    // ====== ゲームコア（ダミー版）
    // 実運用では chess.js 等で SAN→FEN を更新してください
    function applySanToFen(currentFen, san){
      // chess.js を使って、実際にその手を指した後の FEN を返す
      const game = new Chess();
      if (currentFen && currentFen !== 'startpos') {
        try { game.load(currentFen); } catch(e){ alert('FENの読込に失敗: '+e.message); return currentFen; }
      }
      const move = game.move(san, { sloppy: true }); // sloppy:true で e.p. などの表記も許容
      if (!move){
        alert('不正な着手です: '+ san);
        return currentFen; // 無効手なら状態を変えない
      }
      return game.fen();
    }

    function makeProjectedFen(trueFen, rng){
      // trueFen の駒の一部を「不確定化」して B面用の文字列を作る簡単な例
      // （本番ではあなたの投影規則に差し替えてください）
      if (!trueFen || trueFen === 'startpos') {
        // chess.js の開始局面 FEN を使う
        const game = new Chess();
        trueFen = game.fen();
      }
      const parts = trueFen.split(' ');
      const board = parts[0];
      const rows = board.split('/');
      const projectedRows = rows.map(row => {
        let out = '';
        for (const ch of row){
          if (/[1-8]/.test(ch)) { out += ch; continue; }
          // 25% の確率でそのマスを不確定（?）表示にするデモ
          out += (rng() < 0.25) ? '?' : ch;
        }
        return out;
      });
      parts[0] = projectedRows.join('/');
      return parts.join(' ');
    }

    /** @param {TrueState} trueState @param {Rules} rules @param {number} seed */
    function projectToB(trueState, rules, seed){
      if (rules.variant !== 'probProjection') return { fen: trueState.fen };
      const rng = mulberry32(seed + trueState.ply);
      return { fen: makeProjectedFen(trueState.fen, rng) };
    }

    function applyMove(trueState, san){
      const nextFen = applySanToFen(trueState.fen, san);
      return { fen: nextFen, version: trueState.version + 1, ply: trueState.ply + 1 };
    }

    // ====== 状態（Reducer風に実装）
    /** @type {GameState} */
    let state = { trueState: { fen:'startpos', version:0, ply:0 }, bState: { fen:'startpos' }, rules:{ variant:'probProjection' }, seed: 123456789 };

    function startGame(fen, rules, seed){
      state.trueState = { fen, version:0, ply:0 };
      state.rules = rules;
      state.seed = seed ?? Math.floor(Math.random()*1e9);
      state.bState = projectToB(state.trueState, state.rules, state.seed);
      render();
    }

    function onMove(san){
      state.trueState = applyMove(state.trueState, san);
      state.bState = projectToB(state.trueState, state.rules, state.seed);
      render();
    }

    // ====== UI バインド
    const elFenA = document.getElementById('fenA');
    const elFenB = document.getElementById('fenB');
    const elBoardA = document.getElementById('boardA');
    const elBoardB = document.getElementById('boardB');

    function render(){
      elFenA.textContent = state.trueState.fen;
      elFenB.textContent = state.bState.fen;
      drawBoard(elBoardA, state.trueState);
      drawBoard(elBoardB, state.bState);
    }

    // 簡易盤レンダラ（デモ用：実盤ロジックには未対応）
    function drawBoard(container, anyState){
      container.innerHTML = '';
      // 8x8 のダミーマス（FENではなく、可視的な変化確認用）
      for (let r=0;r<8;r++){
        for (let c=0;c<8;c++){
          const d = document.createElement('div');
          d.className = 'sq ' + ((r+c)%2 ? 'dark' : 'light');
          // 盤面の変化を視覚化（雑に：文字数の一部）
          const hash = (anyState.fen.length + r*8 + c) % 10;
          d.textContent = hash === 0 ? '♟' : '';
          container.appendChild(d);
        }
      }
    }

    // イベント
    document.getElementById('btnStart').addEventListener('click', () => {
      const fen = /** @type {HTMLInputElement} */(document.getElementById('initFen')).value || 'startpos';
      const variant = /** @type {HTMLSelectElement} */(document.getElementById('variant')).value;
      const seed = parseInt(/** @type {HTMLInputElement} */(document.getElementById('seed')).value || '0', 10);
      startGame(fen, { variant }, seed);
    });

    document.getElementById('btnReset').addEventListener('click', () => {
      startGame('startpos', { variant:'probProjection' }, 123456789);
      /** @type {HTMLInputElement} */(document.getElementById('moveSan')).value = '';
    });

    document.getElementById('btnMove').addEventListener('click', () => {
      const san = /** @type {HTMLInputElement} */(document.getElementById('moveSan')).value.trim();
      if (!san) return;
      onMove(san);
      /** @type {HTMLInputElement} */(document.getElementById('moveSan')).value = '';
    });

    // 初期化
    startGame('startpos', { variant:'probProjection' }, 123456789);
  </script></body>
</html>
